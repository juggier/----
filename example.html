<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>第一个三维场景</title>
    <link rel="stylesheet" type="text/css" href="example.css">

</head>

<body>
    <div id = "container">
        <input type="radio" class="input_radio" name="inputType" id="inputType" value="1" checked>生成地图
        <input type="radio" class="input_radio" name="inputType" id="inputType" value="2">导入地图
        <input id="input" type="file">
        <input id ="export" type="button" value="导出地图">
        <canvas id = "Map"></canvas>
        <div id = "labels"></div>
    </div>

    <script type="module">

        import * as THREE from './build/three.module.js';
        import {OrbitControls} from './jsm/controls/OrbitControls.js';
        import {CameraControl} from './CameraControl.js';
        import {LOD} from './LOD.js';
        import {Hex} from './HexMap.js';

        let canvas, scene;
        let camera, camera_control, renderer;
        let row, colume; 
        let hex_map;
        let low_heights = [], middle_heights = [];
        let jungles = [], houses = [], points = [[46,47],[46,48],[47,47]];
        let renderRequested = false;

        let LODLEVEL = { LEVEL0: 0, LEVEL1: 1, LEVEL2: 2, LEVEL3: 3 };
        let POINTS = { normal: 0, subordination: 1, important: 2 };
        let LANDS = { flat: 0, residential: 1, jungle: 2, country_road: 3, normal_road: 4, highway: 5 };
        let ZOOMS = [2, 0.9, 0.5, 0.25];

        main();
        render();

        function main(){

            canvas = document.querySelector("#Map");
            renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha:true });
            scene = new THREE.Scene();

            //Camera
            camera = CreateCamera(canvas);
            camera_control = new CameraControl(camera,renderer.domElement);
            camera_control.update();

            //Lighting
            const point = new THREE.PointLight(0xffffff);
            point.position.set(400, 200, 300);
            scene.add(point);

            //环境光
            const ambient = new THREE.AmbientLight(0x444444);
            scene.add(ambient);

            //判断类型
            let type = 1;
            const radio = document.getElementsByName("inputType");
            radio[0].onclick = function(){

                type = radio[0].value;

            };
            radio[1].onclick = function () {

                type = radio[1].value;

            };
            

            //生成地图或者导入地图
            const input = document.querySelector('input[type=file]');
            input.addEventListener('change',()=>{

                const reader = new FileReader();
                reader.readAsBinaryString(input.files[0]);
                reader.onload = ()=>{

                    const result = reader.result;

                    if(type == 1){

                        GenerateMap(result);

                    }else if(type == 2){

                        InputMap(result);

                    }

                }
            },false);
            
            //按钮事件
            const botton = document.querySelector('#export');
            botton.addEventListener('click', e =>{mapToJson(botton,e)},false);


            camera_control.addEventListener('change', requestRenderIfNotRequested);
            window.addEventListener('resize', requestRenderIfNotRequested);

            // window.addEventListener('keydown', (e) => {
            //     e.preventDefault();
            //     window.focus();
            // });
        }

        function GenerateMap(result){

            let datas = result.split('\n');

            let heights = [];

            row = 81;
            colume = 81;

            for (let i = 0; i < row * colume; i++) {
                //计算每个点高程
                const elevation = Math.ceil((parseInt(datas[i]) - 400) / 10) * 10;

                //高程分类
                if (elevation <= 200) {

                    const _row = parseInt(i / row);
                    const _colume = i % row;

                    middle_heights.push([_row, _colume, elevation]);

                    if (elevation <= 100) {

                        low_heights.push([_row, _colume]);

                    }

                }
                heights.push(elevation);
            }

            console.log(low_heights);
            console.log(middle_heights);
            console.log(heights);

            //绘制
            Draw(heights);
            DrawObjects(points, 'point');
            CreateHouses();
            CreateTrees();
            render();

        }

        function InputMap(result){

            let data = JSON.parse(result);

            row = data.row;
            colume = data.colume;

            let heights = [];
            const map = data.map;


            for(let i = 0; i< map.length ;i++){

                const _row = parseInt(i / row);
                const _colume = i % row;

                heights.push(map[i].elevation);

                if(map[i].point_Level == 1){

                    points.push([_row,_colume]);

                }else if(map[i].land_Level == 1){

                    houses.push([_row,_colume]);

                }else if(map[i].land_Level == 2){
                    
                    jungles.push([_row,_colume]);

                }

            }

            console.log(heights);
            console.log(points);
            console.log(houses);
            console.log(jungles);

            Draw(heights);
            DrawObjects(points, 'point');
            DrawObjects(houses, 'house');
            DrawObjects(jungles, 'tree');
            render();

        }

        function render() {

            renderRequested = undefined;

            if(resizeRendererToDisplaySize(renderer)){
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            camera_control.update();

            renderer.setClearColor(0xb9d3ff, 1);
            renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
            renderer.render(scene, camera);

        }

        function resizeRendererToDisplaySize(renderer){

            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;

            if(needResize)
                renderer.setSize(width,height,false);

            return needResize;

        }

        function requestRenderIfNotRequested() {

            if (!renderRequested) {

                renderRequested = true;
                requestAnimationFrame(render);

            }
        }

        function Draw(datas){
        
            hex_map = new THREE.Group();
            CreateHexes(10, row, colume,datas);
            scene.add(hex_map);
            
            console.log(scene);
            
        }

        function CreateHexes(radius, row, colume,datas) {
            //这里row和colume在这里表示的是相反的（以更正）

            //六角格初始化
            const outerRadius = radius;
            const innerRadius = outerRadius * 0.866025404;
            const height_offset = 1.5 * outerRadius;
            const width_offset = 2 * innerRadius;

            //模型
            const hexGeometry = new THREE.CircleGeometry(outerRadius, 6);
            const hexLineGeometry = new THREE.EdgesGeometry(hexGeometry);

            //材质
            const hexLineMaterial = new THREE.LineBasicMaterial({ color: 0x707070, linewidth: 1 });

            for (let _colume = 0; _colume < colume; _colume++) {
                for (let _row = 0; _row < row; _row++) {
                    //ID和高程
                    const id = parseInt(_colume / 10).toString() + (_colume % 10).toString() + parseInt(_row / 10).toString() + (_row % 10).toString();
                    const elevation = datas[_row+_colume * row];

                    //纹理
                    const detail_tex = CreateMapTexture(24, id, elevation, true);
                    const detail_tex2 = CreateMapTexture(12, id, elevation, true);
                    const simpler_tex = CreateMapTexture(12, id, elevation, false);

                    //绘制
                    //mesh+line
                    const detail_hexmesh = new THREE.Mesh(hexGeometry, new THREE.MeshBasicMaterial({ map: detail_tex }));
                    const detail_hexmesh2 = new THREE.Mesh(hexGeometry, new THREE.MeshBasicMaterial({ map: detail_tex2 }));
                    const simpler_hexmesh = new THREE.Mesh(hexGeometry, new THREE.MeshBasicMaterial({ map: simpler_tex }));
                    const hexLine = new THREE.Line(hexLineGeometry, hexLineMaterial);
                    hexLine.material.depthTest = false;
                    hexLine.renderOrder = 1;

                    //LOD
                    const hexmesh = new LOD();
                    hexmesh.name = 'HEXLOD';
                    hexmesh.addLevel(detail_hexmesh, 0.9);
                    hexmesh.addLevel(detail_hexmesh2, 0.3);
                    hexmesh.addLevel(simpler_hexmesh, 0.2);

                    //位移
                    hexmesh.add(hexLine);
                    hexmesh.rotateZ(-Math.PI / 2);
                    hexmesh.position.x = width_offset * _row + (_colume % 2 == 0) * -width_offset * 0.5;
                    hexmesh.position.y = -height_offset * _colume;
                    hexmesh.updateWorldMatrix(true, true);

                    //数据存储
                    const hex_pos = new THREE.Vector2(hexmesh.position.x, hexmesh.position.y);
                    const hex = new Hex(hex_pos, id, elevation);
                    hex.row = _colume;
                    hex.colume = _row;
                    hex.add(hexmesh);

                    // const axes = new THREE.AxesHelper();
                    // axes.material.depthTest = false;
                    // axes.renderOrder = 1;
                    // hex.add(axes);

                    hex_map.add(hex);
                }
            }

            camera.lookAt(hex_map);

        }

        function CreateMapTexture(size,position,elevation,detail){

            const text_ctx = document.createElement('canvas').getContext('2d');
            const borderSize = 2;
            const width = text_ctx.measureText(name).width + 2 * borderSize;
            const height = 2 * (size + borderSize);
            text_ctx.canvas.width = size*8;
            text_ctx.canvas.height = size*8;
            
            let r,g,b;

            if(elevation <= 200){
                r = 255;
                g = Math.max(186,255 - (elevation / 200) * (255 - 186) );
                b = Math.max(107,255 - (elevation / 200) * (255 - 107) );
            }
            else if(elevation > 200 && elevation < 500){
                r = Math.max(130, 255 - ((elevation - 200) / 300) * (255 - 130));
                g = Math.max(95, 186 - ((elevation - 200) / 300) * (186 - 95));
                b = Math.max(55, 107 - ((elevation - 200) / 300) * (107 - 55));
            }
            else if (elevation >= 500 ) {
                r = 130;
                g = Math.min(130, 95 + ((elevation - 500) / 400) * (130 - 95));
                b = Math.min(130, 55 + ((elevation - 500) / 400) * (130 - 55));
            }

            text_ctx.fillStyle = `rgba(${r},${g},${b},1)`;
            text_ctx.fillRect(0, 0, text_ctx.canvas.width, text_ctx.canvas.height);

            if(detail){
                text_ctx.fillStyle = '#000000';
                text_ctx.font = `${size}px sans-serif`;
                text_ctx.textAlign = "center";
                text_ctx.Baseline = "middle";
            
                text_ctx.fillText(position, text_ctx.canvas.width/2, text_ctx.canvas.height / 3);
                text_ctx.fillText(elevation, text_ctx.canvas.width/2, text_ctx.canvas.height / 1.3);
            }

            const texture = new THREE.CanvasTexture(text_ctx.canvas);
            texture.minFilter = THREE.LinearFilter;
            const text_material = new THREE.MeshBasicMaterial({ map: texture });
            texture.center.set(0.5, 0.5);
            texture.rotation = Math.PI / 2;
            
            return texture;

        }

        function CreateHouses() {
                //判断条件1:是否高程小于100
                for (let i = 0; i < low_heights.length; i++) {

                    let point_dist = 31;
                    let neighbor_count = 0;
                    let nearest_neighbor_dist = 0;

                    //判断条件2：周围是否有距离8以内的其他居民楼且数量少于等于2个（多于直接跳过该点，少于获得3分）
                    
                    for (let j = 0; j < houses.length; j++) {

                        const neighbor_dist = coffset_distance(low_heights[i][0],low_heights[i][1],houses[j][0],houses[j][1]);

                        if (neighbor_dist <= 8) {
                            neighbor_count++;
                            if (neighbor_count > 2) {
                                break;
                            }
                            nearest_neighbor_dist = Math.min(nearest_neighbor_dist, neighbor_dist);

                        }

                    }

                    if (neighbor_count > 2) {

                        continue;

                    }

                    //条件3：绝对距离夺控点10以内，根据距离从近到远随机获得（10-2分）,否则跳过该点
                    for (let j = 0; j < points.length; j++) {

                        const dist = coffset_distance(low_heights[i][0], low_heights[i][1], points[j][0], points[j][1]);

                        if (dist > 30) {

                            point_dist = dist;
                            break;

                        }
                        point_dist = Math.min(point_dist, dist);
                    }

                    if (point_dist > 20) {

                        continue;

                    }

                    //条件4：条件2附近没有距离10以内的居民楼但是10米以外有那么获得6分；
                    //计算得分:
                    const max = (Math.abs(10 - point_dist) / 10 * 10 + 2) + (neighbor_count == 0 && nearest_neighbor_dist >= 10) * 6;
                    let result = 0;

                    if (max >= 6) {

                        result = Math.floor(Math.random() * 11);
                    }

                    //如果得分大于6则创建居民楼
                    if (result > 7) {

                        houses.push([low_heights[i][0],low_heights[i][1]]);
                    }
                }

                console.log(houses);
                DrawObjects(houses, 'house');
                
            }
        
        function CreateTrees(){
            //判断条件1:是否高程小于300 （根据海拔高度获得1-3分，根据高度越高越小）
            for(let i = 0;i < middle_heights.length; i++){

                let point_dist = 31;
                let house_dist = 8;
                let neighbor_count = 0;
                let nearest_neighbor_dist = 0;

                let result = parseInt( (300 - middle_heights[i][2]) / 100) + 1;

                //超过夺控点30距离跳过
                for (let j = 0; j < points.length; j++) {

                    const dist = coffset_distance(middle_heights[i][0],middle_heights[i][1],points[j][0],points[j][1])

                    if (dist > 30) {

                        point_dist = dist;
                        break;

                    }

                    point_dist = Math.min(point_dist, dist);

                }

                if (point_dist > 30) {
                    continue;
                }

                //判断条件2：周围是否有距离10以内的其他丛林且数量少于等于2个（多于直接跳过该点，少于获得1-2分，越多越少）
                for (let j = 0; j < jungles.length; j++) {

                    const neighbor_dist = coffset_distance(middle_heights[i][0], middle_heights[i][1], jungles[j][0], jungles[j][1]);

                    if (neighbor_dist <= 10) {

                        neighbor_count++;

                        if (neighbor_count > 2) {

                            break;

                        }

                        nearest_neighbor_dist = Math.min(nearest_neighbor_dist, neighbor_dist);

                    }

                }

                if (neighbor_count > 2) {

                    continue;
                }
                else if (neighbor_count == 2) {

                    result += 2;

                } else {

                    result += 1;

                }

                //条件3：距离6以内,不能出现居民区,否则跳过该点(根据距离获得1-3分)
                for (let j = 0; j < houses.length; j++) {

                    const dist = coffset_distance(middle_heights[i][0], middle_heights[i][1], houses[j][0], houses[j][1]);
                    
                    if (dist <= 6) {

                        house_dist = dist;
                        break;
                    }

                    house_dist = Math.max(house_dist, dist);
                }

                if (house_dist <= 6) {

                    continue;

                } else {

                    result += Math.ceil( (Math.max(12, house_dist) - 6) / 6 ) * 3;

                }


                //条件4：条件2附近没有距离8以内的居民楼且距离最近的丛林大于10（根据距离获得1-3分距离越远越多）
                if (neighbor_count == 0 && nearest_neighbor_dist >= 10) {

                    result += Math.ceil((Math.max(16, nearest_neighbor_dist) - 10) / 6) * 3;

                }

                //计算得分:
                //console.log(result);
                if (result >= 7) {

                    result = Math.floor(Math.random() * 11);

                }

                //如果得分大于6则创建丛林
                if (result >= 7) {

                    jungles.push([middle_heights[i][0],middle_heights[i][1]]);

                }

                    
            }
                
            console.log(jungles);
            DrawObjects(jungles,'tree');

        }

        function DrawObjects(objects,type){

            //网格数据
            const objectGeometries = [
                new THREE.PlaneGeometry(15, 15),
                new THREE.PlaneGeometry(20, 20),
                new THREE.PlaneGeometry(25, 25)
            ];

            //贴图
            const loader = new THREE.TextureLoader();
            let material,tag;
            switch(type){

                case 'point':
                    material = new THREE.MeshBasicMaterial({
                        map: loader.load('./textures/points.png'),
                        transparent: true
                    });
                    break;
                case 'house':
                    material = new THREE.MeshBasicMaterial({
                        map: loader.load('./textures/house1.png'),
                        transparent: true
                    });
                    break;
                case 'tree':
                    material = new THREE.MeshBasicMaterial({
                        map: loader.load('./textures/tree2.png'),
                        transparent: true
                    });
                    break;    

            }

            material.depthTest = false;
            material.renderOrder = 1;

            //绘制
            for(let i = 0; i < objects.length;i++){

                const _row = objects[i][0];
                const _colume = objects[i][1];
                const id = parseInt(_row / 10).toString() + (_row % 10).toString() + parseInt(_colume / 10).toString() + (_colume % 10).toString();

                let hex = hex_map.getObjectByName(id);
                
                switch (type) {

                    case 'point':
                        hex.point_Level = 1;
                        break;
                    case 'house':
                        hex.land_Level = 1;
                        break;
                    case 'tree':
                        hex.land_Level = 2;
                        break;

                }

                const detail_objectmesh = new THREE.Mesh(objectGeometries[0], material);
                const detail_objectmesh2 = new THREE.Mesh(objectGeometries[1], material);
                const simpler_objectmesh = new THREE.Mesh(objectGeometries[2], material);

                const objectMesh = new LOD();
                objectMesh.name = 'ObjectLOD';
                objectMesh.addLevel(detail_objectmesh, 0.9);
                objectMesh.addLevel(detail_objectmesh2, 0.3);
                objectMesh.addLevel(simpler_objectmesh, 0.2);
                objectMesh.position.x = hex.pos.x;
                objectMesh.position.y = hex.pos.y;
                hex.add(objectMesh);

            }
        
        }

        function CreateCamera(canvas){

            const left = -canvas.width / 2;
            const right = canvas.width / 2;
            const top = canvas.height / 2;
            const bottom = -canvas.height / 2;
            // let s = 10;//三维场景的显示系数，越大范围越大
            camera = new THREE.OrthographicCamera(left, right, top, bottom, -1, 50);
            camera.lookAt(0, 0, 0);//设置相机方向(指向场景对象)
            return camera;

        }

        function UpdateLOD(scene,camera){
            let zoom = camera.zoom;
            
        }

        function getRndInteger(min, max) {
                return Math.floor(Math.random() * (max - min)) + min;
            }
        
        //六角网格的相关算法
        //直角坐标转网格坐标
        function offset_to_cube(row, colume) {
                    const x = row - (colume - (colume & 1)) / 2;
                    const z = colume;
                    const y = -x - z;
                    return [x, y, z];
                }

        //以直角坐标查询周围网格
        function offset_neighbor(direction) {
                    const oddr_directions = [
                        [0, +1], [-1, +1], [-1, 0], [0, -1], [+1, 0], [+1, +1]
                    ];
                    const dir = oddr_directions[direction];
                    return [this.row + dir[0], this.colume + dir[1]];
                }

        //测量两个网格之间的距离
        function cube_distance(a, b) {
                    return (Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2])) / 2;
                }

        function coffset_distance(arow, acolume, brow, bcolume) {
                    const ac = offset_to_cube(arow, acolume);
                    const bc = offset_to_cube(brow, bcolume);
                    return cube_distance(ac, bc);
                }

        function mapToJson(botton,event){

            event.preventDefault();

            let array = [];

            for(let i = 0 ; i< hex_map.children.length;i++){

                const json = hex_map.children[i].toJson();
                array.push(json);

            }

            const json = {"row":row, "colume":colume, "map":array};
            const blob = new Blob([JSON.stringify(json)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download',"map.txt");
            link.click();
        }
</script> 
</body>